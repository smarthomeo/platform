'use strict';

var React = require('react');
var openChannel = require('@sendbird/chat/openChannel');
var UserProfileContext = require('../chunks/bundle-YKlDDUzv.js');
var uuid = require('../chunks/bundle-KfgcZyeV.js');
var useSendbird = require('../chunks/bundle-BMIzPycb.js');
require('../chunks/bundle-DqhRrRu9.js');
require('../chunks/bundle-BotH0J8Z.js');
require('../chunks/bundle-DBIZFnYM.js');
require('@sendbird/chat');
require('@sendbird/chat/groupChannel');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefaultCompat(React);

var OpenChannelSettingsContext = React__default.default.createContext(null);
var OpenChannelSettingsProvider = function (props) {
    var _a, _b, _c, _d;
    var children = props.children, channelUrl = props.channelUrl, onCloseClick = props.onCloseClick, onChannelModified = props.onChannelModified, onBeforeUpdateChannel = props.onBeforeUpdateChannel, onDeleteChannel = props.onDeleteChannel;
    // fetch store from <SendbirdProvider />
    var _e = useSendbird.useSendbird().state, stores = _e.stores, config = _e.config;
    var sdk = (_a = stores === null || stores === void 0 ? void 0 : stores.sdkStore) === null || _a === void 0 ? void 0 : _a.sdk;
    var isSDKInitialized = (_b = stores === null || stores === void 0 ? void 0 : stores.sdkStore) === null || _b === void 0 ? void 0 : _b.initialized;
    var logger = config === null || config === void 0 ? void 0 : config.logger;
    var currentUserId = (_c = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId;
    var _f = React.useState(null), currentChannel = _f[0], setChannel = _f[1];
    var _g = React.useState(false), isChannelInitialized = _g[0], setChannelInitialized = _g[1];
    React.useEffect(function () {
        if (!channelUrl || !sdk.openChannel) {
            setChannel(null);
            return;
        }
        sdk.openChannel.getChannel(channelUrl)
            .then(function (channel) {
            logger.info('open channel setting: fetched', channel);
            // TODO: Add pending status
            channel.enter()
                .then(function () {
                setChannel(channel);
                logger.info('OpenChannelSettings | Succeeded to enter channel', channel === null || channel === void 0 ? void 0 : channel.url);
                setChannelInitialized(true);
            })
                .catch(function (error) {
                setChannel(null);
                logger.warning('OpenChannelSettings | Failed to enter channel', error);
            });
        })
            .catch(function (error) {
            logger.error('open channel setting: error fetching', error);
            setChannel(null);
        });
        return function () {
            if (currentChannel && currentChannel.exit) {
                currentChannel.exit()
                    .then(function () {
                    logger.info('OpenChannelSettings | Succeeded to exit channel', currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url);
                })
                    .catch(function (error) {
                    logger.warning('OpenChannelSettings | Failed to exit channel', error);
                });
            }
        };
    }, [channelUrl, isSDKInitialized]);
    React.useEffect(function () {
        var _a;
        var channelHandlerId = uuid.uuidv4();
        if (currentChannel !== null && ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a === void 0 ? void 0 : _a.addOpenChannelHandler)) {
            var channelHandlerParams = new openChannel.OpenChannelHandler({
                onOperatorUpdated: function (channel) {
                    if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
                        setChannel(channel);
                    }
                },
                onUserMuted: function (channel, user) {
                    if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
                        setChannel(channel);
                    }
                },
                onUserUnmuted: function (channel, user) {
                    if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
                        setChannel(channel);
                    }
                },
                onUserBanned: function (channel, user) {
                    if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
                        setChannel(null);
                    }
                },
                onUserUnbanned: function (channel, user) {
                    if ((user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
                        setChannel(channel);
                    }
                },
                onChannelChanged: function (channel) {
                    if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
                        setChannel(channel);
                    }
                },
                onChannelDeleted: function (channelUrl) {
                    if (channelUrl === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
                        setChannel(null);
                    }
                },
            });
            sdk.openChannel.addOpenChannelHandler(channelHandlerId, channelHandlerParams);
        }
        return function () {
            var _a, _b, _c;
            if (((_a = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a === void 0 ? void 0 : _a.removeOpenChannelHandler) && channelHandlerId) {
                logger.info('OpenChannelSettings | Removing channel handlers', channelHandlerId);
                (_c = (_b = sdk.openChannel).removeOpenChannelHandler) === null || _c === void 0 ? void 0 : _c.call(_b, channelHandlerId);
            }
        };
    }, [channelUrl]);
    return (React__default.default.createElement(OpenChannelSettingsContext.Provider, { value: {
            channelUrl: channelUrl,
            channel: currentChannel,
            isChannelInitialized: isChannelInitialized,
            setChannel: setChannel,
            onCloseClick: onCloseClick,
            onChannelModified: onChannelModified,
            onBeforeUpdateChannel: onBeforeUpdateChannel,
            onDeleteChannel: onDeleteChannel,
        } },
        React__default.default.createElement(UserProfileContext.UserProfileProvider, { isOpenChannel: true, renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile, disableUserProfile: (_d = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _d !== void 0 ? _d : config === null || config === void 0 ? void 0 : config.disableUserProfile }, children)));
};
var useOpenChannelSettingsContext = function () {
    var context = React__default.default.useContext(OpenChannelSettingsContext);
    if (!context)
        throw new Error('OpenChannelSettingsContext not found. Use within the OpenChannelSettings module.');
    return context;
};

exports.OpenChannelSettingsProvider = OpenChannelSettingsProvider;
exports.useOpenChannelSettingsContext = useOpenChannelSettingsContext;
//# sourceMappingURL=context.js.map
